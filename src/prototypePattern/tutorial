 原型模式
 原型模式(Prototype Pattern) 是用於創建重複的物件，同時又能保持性能
 這種模式是實現了一個原型介面，該介面用於創建當前物件的clone，當直接創建物件的代價比較大時，
 則採用這種模式，例如:一個物件需要在一個高代價的數據庫之後被創建，我們可以緩存該物件，在下
 一個請求時返回它的clone，在需要的時候更新數據庫，以此來減少數據庫的調用
 **一般不用這裡自訂義clone，可以直接override java 的clone()

 主要解決 :
 在運行期建立和刪除原型
 ---------------------------------------------------------------------------------------------------
 何時使用 :
 1 、當一個系統應該獨立於它的產品創建、建構和表示時
 2 、當要實例化的類是在運行時刻指定時，例如 : 通過動態裝載
 3 、為了避免創建一個與產品類層次平行的工廠類層次時
 4 、當一個類的實例只能有幾個不同狀態組合中的一種時，建立相應數目的原型並clone它們
 可能比每次用合適的狀態手工實例化該類更方便一些
 ---------------------------------------------------------------------------------------------------
 如何解決 :
 利用已有的一個原型物件，快速地生成和原型物件一樣的實例
  ---------------------------------------------------------------------------------------------------
  關鍵代碼 :
  1 、實現clone操作，在Java繼承Cloneable，重寫clone()，在.Net 中可以使用Object 類的MemberwiseClone()
  方法來實現物件的淺複製或通過序列化的方式來深複製
  2 、原型模式同樣用於隔離類物件的使用者和具體類型(易變類)之間的耦合關係，它同樣要求這些
  "易變類"雍有穩定的介面
    ---------------------------------------------------------------------------------------------------
    應用案例 :
     1 、細胞分裂
     2 、Java 中的 Object clone()方法
    ---------------------------------------------------------------------------------------------------
    優點 :
    1 、性能提高
    2 、逃避構造函數的約束
    ---------------------------------------------------------------------------------------------------
    缺點 :
     1 、配clone方法需要對類的功能進行通盤考慮，這對於全新的類不是很難，但對於已有的類不
     一定很容易，特別當一個類引用不支持串行化的間接對象，或者引用含有循環結構的時候
     2 、必須實現Cloneable介面
      ---------------------------------------------------------------------------------------------------
     使用場景 :
     1 、資源優化場景
     2 、類初始化需要消化非常多的資源，這個資源包刮數據、硬件資源等
     3 、性能和安全要求的場景
     4 、通過new產生一個物件需要非常繁瑣的數據準備或訪問權限，則可以使用原型模式
     5 、一個物件多個修改者的場景
     6 、一個物件需要提供給其他物件訪問，而且各個調用者可能都需要修改其值時，
     可以考慮使用原型模式拷貝多個物件供調用者使用
     7 、在實際項目中，原型模型很少單獨出現，一般是和工廠模式一起出現，通過
     clone的方法創建一個物件，然後由工廠方法提供給調用者，原型模式已經與java
     融為一體，大家可以隨手拿來使用
      ---------------------------------------------------------------------------------------------------
     注意事項 : 與通過對一個類進行實例化來構造新物件不同的是，原型模型是通過
     拷貝一個現有物件生成新物件的，淺拷貝實現Cloneable，重寫，深拷貝是通過實現
     Serializable讀取二進制流